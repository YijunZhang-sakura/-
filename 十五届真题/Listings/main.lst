C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2025 16:11:13 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: C:\Keil_v5\C51\BIN\C51.EXE user\main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(.\common;.\drive;.\user) DEB
                    -UG OBJECTEXTEND PRINT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          // 主程序系统
   2          /*  头文件包含 */
   3          #include <stc15f2k60s2.h>
   4          #include <Key.h>
   5          #include <Seg.h>
   6          #include <su_common_typedef.h>
   7          #include <ds1302.h>
   8          #include <iic.h>
   9          #include <Led.h>
  10          /*  全局变量定义 */
  11          uint8_t Seg_Mode; // 0-频率 1-参数 2-时间显示 3-回显模式
  12          uint8_t Key_Slow_Down;
  13          uint8_t Key_Old,Key_Val,Key_Down,Key_Up;
  14          uint8_t Seg_Pos;
  15          uint16_t Seg_Slow_Down;
  16          uint8_t Seg_Buf[8] = {16,16,16,16,16,16,16,16};
  17          uint8_t Frequence[5] = {16,2,3,5,0};
  18          int16_t ChaoXian[4] = {2,0,0,0};
  19          int16_t ChaoXian_Data = 2000;
  20          int16_t JiaoZhun_Data;
  21          int16_t JiaoZhun[4] = {16,16,16,0};
  22          uint8_t ucRtc[3] = {13,03,05};
  23          int16_t Time_100ms;
  24          int16_t Count_Frequence;
  25          int16_t Total_Frequence;
  26          uint8_t time00 = 65536-1000;
  27          bit CanShu_Mode,HuiXian_Mode;
  28          int16_t Max_Frequence[5] = {16,2,3,5,0};
  29          uint8_t Max_Time[3] ={13,03,05};
  30          int16_t Max_Count;
  31          uint8_t Time_200ms;
  32          //S5按键处理
  33          void S5_Function(){
  34   1      if(Seg_Mode ==1)//0是超限 1是校准
  35   1      CanShu_Mode = ~CanShu_Mode;
  36   1      if(Seg_Mode == 3)//0是频率 1是时间
  37   1      HuiXian_Mode = ~HuiXian_Mode;
  38   1      
  39   1      }
  40          
  41          //S8按键处理
  42          void S8_Function(){
  43   1        int16_t temp = 0;
  44   1      if(Seg_Mode ==1){
  45   2        if(CanShu_Mode ==0)//超限
  46   2          ChaoXian_Data = (ChaoXian_Data>=1000&&ChaoXian_Data<=8000)?(ChaoXian_Data+1000):ChaoXian_Data;
  47   2        else//校准
  48   2          JiaoZhun_Data = (JiaoZhun_Data>=(-900)&&JiaoZhun_Data<=800)?(JiaoZhun_Data+100):JiaoZhun_Data;
  49   2        
  50   2        }//if
  51   1        
  52   1          //更新显示
  53   1          if(JiaoZhun_Data<0){
  54   2        JiaoZhun[0] = 19;
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2025 16:11:13 PAGE 2   

  55   2          temp = -JiaoZhun_Data;
  56   2        JiaoZhun[1] = temp/100%10;
  57   2        JiaoZhun[2] = temp/10%10;
  58   2        JiaoZhun[3] = temp%10;
  59   2      
  60   2          }//符号位 - 
  61   1        if(JiaoZhun_Data>0){ 
  62   2          JiaoZhun[0] = 16; //灭
  63   2        JiaoZhun[1] = JiaoZhun_Data/100%10;
  64   2        JiaoZhun[2] = JiaoZhun_Data/10%10;
  65   2        JiaoZhun[3] = JiaoZhun_Data%10;}
  66   1          
  67   1        if(JiaoZhun_Data == 0){
  68   2            JiaoZhun[0] = 16; //灭
  69   2        JiaoZhun[1] = 16;
  70   2        JiaoZhun[2] = 16;
  71   2        JiaoZhun[3] = 0;
  72   2        
  73   2        }
  74   1        
  75   1          ChaoXian[0] = ChaoXian_Data/1000%10;
  76   1          ChaoXian[1] = ChaoXian_Data/100%10;
  77   1          ChaoXian[2] = ChaoXian_Data/10%10;
  78   1          ChaoXian[3] = ChaoXian_Data%10;
  79   1      
  80   1      }
  81            
  82          
  83          //S9按键处理
  84          void S9_Function(){
  85   1        int16_t temp = 0;
  86   1      if(Seg_Mode ==1){
  87   2        if(CanShu_Mode ==0)//超限
  88   2          ChaoXian_Data = (ChaoXian_Data>=2000&&ChaoXian_Data<=9000)?(ChaoXian_Data-1000):ChaoXian_Data;
  89   2        else//校准
  90   2          JiaoZhun_Data = (JiaoZhun_Data>=(-800)&&JiaoZhun_Data<=900)?(JiaoZhun_Data-100):JiaoZhun_Data;
  91   2        
  92   2        }//if
  93   1          //更新显示
  94   1          if(JiaoZhun_Data<0){
  95   2        JiaoZhun[0] = 19;
  96   2          temp = -JiaoZhun_Data;
  97   2        JiaoZhun[1] = temp/100%10;
  98   2        JiaoZhun[2] = temp/10%10;
  99   2        JiaoZhun[3] = temp%10;
 100   2          }//符号位 - 
 101   1        if(JiaoZhun_Data>0){ 
 102   2          JiaoZhun[0] = 16; //灭
 103   2        JiaoZhun[1] = JiaoZhun_Data/100%10;
 104   2        JiaoZhun[2] = JiaoZhun_Data/10%10;
 105   2        JiaoZhun[3] = JiaoZhun_Data%10;
 106   2        }
 107   1        if(JiaoZhun_Data == 0){
 108   2            JiaoZhun[0] = 16; //灭
 109   2        JiaoZhun[1] = 16;
 110   2        JiaoZhun[2] = 16;
 111   2        JiaoZhun[3] = 0;
 112   2        
 113   2        }
 114   1        
 115   1          ChaoXian[0] = ChaoXian_Data/1000%10;
 116   1          ChaoXian[1] = ChaoXian_Data/100%10;
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2025 16:11:13 PAGE 3   

 117   1          ChaoXian[2] = ChaoXian_Data/10%10;
 118   1          ChaoXian[3] = ChaoXian_Data%10;
 119   1      
 120   1      }
 121          /* 键盘处理函数 */
 122          void Key_Process(){
 123   1          if(Key_Slow_Down) return;
 124   1          Key_Slow_Down = 1;
 125   1          Key_Val = Key_Read();
 126   1          Key_Up=~Key_Val & (Key_Old^ Key_Val); // 检测键释放
 127   1          Key_Down = Key_Val & (Key_Val ^ Key_Old);
 128   1          Key_Old = Key_Val;
 129   1          switch(Key_Down){
 130   2              case 1://S4
 131   2              if(Seg_Mode == 0)  CanShu_Mode = 0;
 132   2              if(Seg_Mode == 2)  HuiXian_Mode = 0;
 133   2              if(++Seg_Mode == 4) Seg_Mode = 0;
 134   2                  break;
 135   2              case 2://S5
 136   2              S5_Function();
 137   2              break;
 138   2              case 5://S8 增加键
 139   2              S8_Function();
 140   2                  break;
 141   2      
 142   2              case 6://S9 减少键
 143   2              S9_Function();
 144   2                  break;
 145   2          }
 146   1      }
 147          /*参数显示*/
 148          void  CanShu_Process(){
 149   1        if(CanShu_Mode == 0){//超限
 150   2                  Seg_Buf[0] = 17 ;//P
 151   2                  Seg_Buf[1] = 1 ;//1
 152   2                  Seg_Buf[2] = 16 ;
 153   2                  Seg_Buf[3] = 16 ;
 154   2                  Seg_Buf[4] = ChaoXian[0] ;
 155   2                  Seg_Buf[5] = ChaoXian[1] ;
 156   2                  Seg_Buf[6] = ChaoXian[2] ;
 157   2                  Seg_Buf[7] = ChaoXian[3] ;
 158   2          return;
 159   2        }
 160   1        else{
 161   2                  Seg_Buf[0] = 17 ;//P
 162   2                  Seg_Buf[1] = 2 ;//1
 163   2                  Seg_Buf[2] = 16 ;
 164   2                  Seg_Buf[3] = 16 ;
 165   2                  Seg_Buf[4] = JiaoZhun[0] ;
 166   2                  Seg_Buf[5] = JiaoZhun[1] ;
 167   2                  Seg_Buf[6] = JiaoZhun[2] ;
 168   2                  Seg_Buf[7] = JiaoZhun[3] ;
 169   2        }
 170   1      }
 171          void HuiXian_Process(){
 172   1        if(HuiXian_Mode == 0){//频率
 173   2                  Seg_Buf[0] = 18 ;//H
 174   2                  Seg_Buf[1] = 15 ;//F
 175   2                  Seg_Buf[2] = 16 ;
 176   2                  Seg_Buf[3] = Max_Frequence[0] ;
 177   2                  Seg_Buf[4] = Max_Frequence[1] ;
 178   2                  Seg_Buf[5] = Max_Frequence[2] ;
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2025 16:11:13 PAGE 4   

 179   2                  Seg_Buf[6] = Max_Frequence[3] ;
 180   2                  Seg_Buf[7] = Max_Frequence[4] ;
 181   2          return;
 182   2        }
 183   1        else{ //时间
 184   2                  Seg_Buf[0] = 18 ;//H
 185   2                  Seg_Buf[1] = 10;//A
 186   2                  Seg_Buf[2] = Max_Time[0]/10%10;
 187   2                  Seg_Buf[3] = Max_Time[0]%10;
 188   2                  Seg_Buf[4] = Max_Time[1]/10%10 ;
 189   2                  Seg_Buf[5] = Max_Time[1]%10 ;
 190   2                  Seg_Buf[6] = Max_Time[2]/10%10 ;
 191   2                  Seg_Buf[7] = Max_Time[2]%10;
 192   2        }
 193   1      
 194   1      }
 195          /* 段码处理函数 */
 196          void Seg_Process(){
 197   1          Read_Rtc(ucRtc);
 198   1          if(Seg_Slow_Down) return;
 199   1          switch(Seg_Mode){
 200   2              case 0://频率显示
 201   2                  Seg_Buf[0] = 15 ;//F
 202   2                  Seg_Buf[1] = 16 ;
 203   2                  Seg_Buf[2] = 16 ;
 204   2                  Seg_Buf[3] = Frequence[0] ;
 205   2                  Seg_Buf[4] = Frequence[1] ;
 206   2                  Seg_Buf[5] = Frequence[2] ;
 207   2                  Seg_Buf[6] = Frequence[3] ;
 208   2                  Seg_Buf[7] = Frequence[4] ;
 209   2                  break;
 210   2      
 211   2              case 1://参数显示
 212   2              CanShu_Process();
 213   2                  break;
 214   2      
 215   2              case 2://时间显示
 216   2                  Seg_Buf[0] = ucRtc[0]/10%10 ;
 217   2                  Seg_Buf[1] = ucRtc[0]%10 ;
 218   2                  Seg_Buf[2] = 19 ;//-
 219   2                  Seg_Buf[3] = ucRtc[1]/10%10 ;
 220   2                  Seg_Buf[4] = ucRtc[1]%10 ;
 221   2                  Seg_Buf[5] = 19 ;//-
 222   2                  Seg_Buf[6] = ucRtc[2]/10%10 ;
 223   2                  Seg_Buf[7] = ucRtc[2]%10 ;
 224   2                  break;
 225   2      
 226   2              case 3://回显模式
 227   2              HuiXian_Process();
 228   2                  break;
 229   2          }
 230   1      }
 231          /* LED处理函数 */
 232          void Led_Process(){
 233   1        if(Seg_Mode == 0){
 234   2          Led_Disp(0,0);
 235   2          if(Time_200ms == 0)     Led_Disp(0,1);
 236   2          if(Total_Frequence>ChaoXian_Data){
 237   3            Led_Disp(1,0);
 238   3            if(Time_200ms == 0) Led_Disp(1,1);
 239   3          }
 240   2          if(Total_Frequence < 0){ 
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2025 16:11:13 PAGE 5   

 241   3            Led_Disp(1,1);
 242   3            Led_Disp(0,0);
 243   3          }
 244   2        }
 245   1        else{
 246   2        Led_Disp(0,0);
 247   2          Led_Disp(1,0);
 248   2            Led_Disp(2,0);
 249   2            Led_Disp(3,0);
 250   2            Led_Disp(4,0);
 251   2            Led_Disp(5,0);
 252   2            Led_Disp(6,0);
 253   2            Led_Disp(7,0);
 254   2        }
 255   1      
 256   1      }
 257          
 258          void Init_Beep_Led(){
 259   1          P2 = (P2 &0x1f) | 0xb0;
 260   1          P0 = 0x00;
 261   1          P2 = 0x1f;
 262   1          P0 = 0xff;
 263   1          P2 = (P2 &0x1f) | 0x80;
 264   1          P0 =0xff;
 265   1          P2 = 0x1f;
 266   1      }
 267          
 268          /* 定时器0初始化 */
 269          void Init_Time(){
 270   1        TMOD = 0x06;    //设置定时器模式
 271   1          TL1 = 64536%256;    //设置定时初值
 272   1          TH1 = 64536/256;    //设置定时初值
 273   1        TF1 = 0;  TF0 = 1;  //清除TF0标志
 274   1        TR1 = 1;  TR0 = 1;  //定时器0开始计时
 275   1        EA = 1;
 276   1        ET0 = 1; ET1 = 1;
 277   1      }
 278          
 279          
 280          
 281          void Update_Frequence(){
 282   1        uint8_t  i,j = 0; 
 283   1        long double temp,FZ,FM;
 284   1        Total_Frequence = 10*Count_Frequence + JiaoZhun_Data;
 285   1        if(Total_Frequence >= 0){
 286   2        Frequence[0] = (Total_Frequence/10000%10 == 0)?16:(Total_Frequence/10000%10);
 287   2        if(Frequence[0] == 16)
 288   2        Frequence[1] = (Total_Frequence/1000%10 == 0)?16:(Total_Frequence/1000%10);
 289   2        else Frequence[1] =(Total_Frequence/1000%10);
 290   2        if(Frequence[1] == 16)
 291   2        Frequence[2] = (Total_Frequence/100%10 == 0)?16:(Total_Frequence/100%10);
 292   2        else Frequence[2] = (Total_Frequence/100%10);
 293   2        if(Frequence[2] == 16)
 294   2        Frequence[3] = (Total_Frequence/10%10 == 0)?16:(Total_Frequence/10%10);
 295   2        else Frequence[3] = (Total_Frequence/10%10);
 296   2        Frequence[4] = Total_Frequence%10;}
 297   1        else{//负数情况
 298   2          Frequence[0] = 16;
 299   2          Frequence[1] = 16;
 300   2          Frequence[2] = 16;
 301   2        Frequence[3] = 20;
 302   2        Frequence[4] = 20;
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2025 16:11:13 PAGE 6   

 303   2        }
 304   1        //Da输出部分
 305   1        if(Total_Frequence < 0 )  Da_Write(0);
 306   1        if(Total_Frequence >=0&&Total_Frequence<= 500) Da_Write(51);
 307   1        if(Total_Frequence > 500 && Total_Frequence<= ChaoXian_Data ){
 308   2        FZ=Total_Frequence-500;
 309   2          FM = ChaoXian_Data-500;
 310   2          temp = 51+(204*(FZ/FM));
 311   2          Da_Write(temp);
 312   2        }
 313   1        if(Total_Frequence> ChaoXian_Data) Da_Write(255);
 314   1        if(Max_Count < Total_Frequence){
 315   2          Max_Count = Total_Frequence;
 316   2          for(j = 0;j<3;j++) Max_Time[j] = ucRtc[j];
 317   2          for(i=0;i<5;i++)Max_Frequence[i] = Frequence[i];
 318   2        }
 319   1        
 320   1        Count_Frequence = 0;
 321   1      }
 322          
 323          /* 定时器0中断服务 */
 324          void Time0_Serve() interrupt 1{
 325   1          TH0 = 0xff;
 326   1          TL0 = 0xff;
 327   1          Count_Frequence++;
 328   1      }
 329          
 330          /* 定时器1中断服务 */
 331          void Time1_Serve() interrupt 3{
 332   1          TL1 = 64536%256;    //设置定时初值
 333   1          TH1 = 64536/256;    //设置定时初值
 334   1          Led_Process();
 335   1          P2 = 0xff;
 336   1          if(++Key_Slow_Down == 10) Key_Slow_Down = 0;
 337   1          if(++Seg_Pos == 8) Seg_Pos = 0;
 338   1          if(Seg_Slow_Down == 100)    Seg_Slow_Down = 0;
 339   1          if(++Time_200ms == 200)  Time_200ms = 0;
 340   1          if(++Time_100ms == 100){
 341   2            Time_100ms = 0;
 342   2            Update_Frequence();
 343   2          }
 344   1          Seg_Display(Seg_Pos,Seg_Buf[Seg_Pos]);
 345   1          
 346   1      }
 347          /* 主函数 */
 348          void main(){
 349   1          Init_Time();
 350   1          Init_Beep_Led();
 351   1          Set_Rtc(ucRtc);
 352   1          while(1){
 353   2              Key_Process();
 354   2              Seg_Process();
 355   2              Led_Process();
 356   2          }
 357   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   2026    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
C51 COMPILER V9.60.7.0   MAIN                                                              04/07/2025 16:11:13 PAGE 7   

   DATA SIZE        =     68       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      2    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
